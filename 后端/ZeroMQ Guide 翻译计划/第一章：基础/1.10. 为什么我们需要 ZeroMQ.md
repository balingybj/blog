# 为什么我们需要 ZeroMQ

> 本文翻译自 [Why We Needed ZeroMQ](http://zguide.zeromq.org/page:all#Why-We-Needed-ZeroMQ)

现在很多应用程序都由跨越网络（局域网或因特网）的组件组成。所以开发人员最终都需要面对消息传递。部分开发人员会使用现有消息队列产品，但是多数情况下都是开发人员自己处理消息，使用 TCP 或 UDP 协议。这些协议不难使用，但是从 A 向 B 发送几个字节距离以某种可靠的方式进行消息传递还有很大距离。

我们先来看看使用原始 TCP 时会遇到的典型问题。任何可重用的消息层都需要解决下面列表中的所有或大部分问题：

- **怎么处理 I/O ?** 应用是阻塞在 I/O 上，还是在后台处理 I/O ?  这个决策很关键，阻塞 I/O 会导致伸缩性不好的体系结构，后台 I/O 又很难保证正确执行。
- **怎么处理动态组件，也就是暂时消失的部分？** 我们是否将组件划分为 “客户端” 和 “服务端” 并要求服务端用不消失？另外，如果我们想让各个服务端互联呢？我们是否需要每隔几秒尝试连接？
- **怎么表示消息 ？**怎么构建数据，让数据便于读写、避免缓冲区溢出、即能高效地处理小消息、又能满足传输像视频哪样的大消息？
- **怎么处理不能立即交付的消息？**例如，在等待一个消息的接收方重新上线时，我们是丢掉该消息还是将其缓存到数据库，还是一个内存队列中？
- **怎么处理丢失的消息?** 我们是等待新数据，请求重发，或者构建一个可靠层来确保消息不会丢失？ 如果该可靠层自身奔溃了呢？
- **如果需要使用不同的网络协议怎么办？** 比如，多播而不是 TCP 单播， 或者 IPv6， 我们是否需要重写应用程序，或者在某个抽象层中传输？
- **怎么路由消息？** 可以将同一份消息发送给多个对等点吗？可以将回复发送回给原始请求者吗？
- **如何为某一种语言编写 API ？** 是重新实现一个线级协议还是重新打包一个库，如果选择前者，怎么保证协议栈的效率和稳定性？ 如果选择后者，我们如何保证互操作性？
- **怎么表示数据，让它在不同的体系结构之间都可读？** 我们是否对数据类型强制执行特定编码？ 这在多大程度上是消息传递系统而不是更高层的工作？
- **怎么处理网络错误？** 等待并重试、忽略、还是中止？

以一个典型的开源项目  [Hadoop Zookeeper](http://hadoop.apache.org/zookeeper/) 为例，看看它 [src/c/src/zookeeper.c](http://github.com/apache/zookeeper/blob/trunk/src/c/src/zookeeper.c) 文件中的 C API 。我 2013 年 1 月读该文件的时候，它有 4200 行无注释的神秘代码，用于实现客户端/服务端网络通信协议。而且我知道它为了网络性能，使用了 `poll` 而不是 `select`。但说实话，Zookeeper 应该使用一个通用的消息层和一个显示文档化的线级协议。对于一个团队来说，一遍一遍地造轮子是极其浪费时间的。

但是如何创建一个可重用的消息层呢？ 为什么在如此多的项目都需要该技术的情况下，开发人员还是在用非常困难的方式在代码中使用直接使用 TCP 套接字，然后一遍一遍的解决上述列表中提到的问题呢？

事实证明，构建一个可重用的消息层极其困难，这就是为什么很少有自由/开源软件项目尝试解决该问题，以及为什么商业消息传递产品复杂、昂贵、不灵活又不健壮。2006 年，iMatix 设计了  [AMQP](http://www.amqp.org/) ，这也许是提供给自由/开源软件开发人员的第一个消息系统可重用配方。AMQP 比其他设计好很多，[但任然相对复杂、昂贵，并且脆弱](http://www.imatix.com/articles:whats-wrong-with-amqp)。你需要花几周时间学习使用它，再花几个月的时间使用它创建一个稳定的体系结构，保证事情棘手时不会崩溃。

![Messaging as it Starts](https://github.com/imatix/zguide/raw/master/images/fig7.png)

大多数通讯项目，例如 AMQP，在解决上述长列表中的问题时都会引入一个新的概念——“broker”，负责寻址、路由和排队。结果就是一个客户端/服务端协议，或一组基于未文档化的协议之上的 API，应用通过该组 API 和 broker 通信。Broker 在减少大型网络的复杂性方面是个好东西，但在类似 Zookeeper 这样的产品中添加基于 broker 的消息会让情况变得更糟。每引入一个 broker 就意味着增加一个额外的机器，和一个新的单点故障。Broker 会迅速成为瓶颈和一个需要管理的新风险。在软件支持的情况下，我们可能会添加第二个、第三个、第四个 broker，并制定一些故障转移计划。就是这样，开发人员创造了更多活动组件，更多的复杂性，以及更多需要打破的东西。

以 broker 为中心的公司需要自己的运维团队。你需要日日夜夜地监控这些 broker 并在它们出故障时修复它们。你需要机器，需要备用机器，并需要人来管理这些机器。这种方案用于某类大型应用才合算，这类应用由需要活动部分组成，并有几个团队的人花费几年时间完成。

![**Messaging as it Becomes**](https://raw.githubusercontent.com/booksbyus/zguide/master/images/fig8.png)

所以中小型开发团队陷入了困境。他们要么避免网络编程，构建出不能伸缩的的、单一的应用，要么跳入网络编程的世界，并构建出脆弱、复杂且难以维护的应用，要么押注于一个消息传递产品，最终开发出可伸缩的应用，但这些应用依赖于昂贵且容易崩溃的技术。一直也没有真正好的选择，这也许能解释消息传递很大程度上还停留在上个世纪并能激起强烈的情感：对用户来说是负面情绪，对销售支持和许可的人来却是愉悦。

我们需要的是可以传递消息东西，并可以在任何应用中非常简单和廉价的实现，几乎零成本。它应该是一个可以链接的库，没有任何其他依赖，没有额外的移动部件，没有额外的风险。它应该可以运行在任何操作系统上，并适用于任何编程语言。

答案就是 ZeroMQ：一个高效的、可以嵌入的库，不需要多大成本就可以让一个应用在网络上保持良好的弹性。

它的特性如下：

- 在后台线程中异步处理 I/O。这些后台线程使用无锁的数据结构和应用线程通信，所以并发的 ZeroMQ 应用不需要锁、信号量、或其他等待状态。
- 组件可以热插拔，ZeroMQ 会自动重连。这意味着你可以按任意顺序启动组件。你可以创建“面向服务的体系结构”（SOAs），其中服务可以随时加入和离开网络。
- 可以处理过满的队列（称为“高水位”）。一个队列满后，ZeroMQ 根据正在执行的消息类型（后文中所谓的“模式”）自动阻塞发送者，或者丢弃消息。
- 允许应用通过任意机制相互通信：TCP，多播，进程内，进程间。你不需要修改代码就可以使用不同的传输机制。
- 安全地处理慢速和阻塞的消费者。不同的消息模式使用不同的策略来保证这一点。
- 支持各种模式来路由消息，比如请求-应答模式，发布-订阅模式。这些模式对应于你创建的拓补结构，即网络结构。
- 支持创建代理来对消息进行排队、转发、或捕获，通过一个调用就行。代理可以减少网络的互联复杂性。
- 通过在网络上使用一个简单的框架，将消息原样传递。如果你发送了一个 10k 的消息，该消息被收到时也是 10k。
- 不将任何格式强加到消息上。从 0 到 GB 大小的消息都支持。你可以在 ZeroMQ 之上选择其他产品来表示数据，比如 msgpack、Google 的 protocol、或其他产品。
- 智能处理网络错误，在有意义的情况下自动重试。
- 减少你的碳排放量。用更少的 CPU 做更多的事情，减少用电，让你的旧机器使用更长的时间。阿尔·戈尔（著名环保学家）也会喜欢 ZeroMQ 的。

实际上 ZeroMQ 做的远不止这些。它对如何开发具有网络能力的应用具有颠覆性的影响。从表面上看，它是一个受套接字启发的 API，你一般会调用 `zmq_recv()` 和 `zmq_send()`。但是消息处理很快成为中心循环，你的应用程序很快分解为一组消息处理任务。这很优雅，也很自然。并且它是可伸缩的：每个任务都映射到一个节点，节点之间通过任意传输机制进行通信。两个节点共一个进程（节点是线程），两个节点共一台机器（节点是进程），或者两个节点共一个网络（节点是机器）——都是一样的，应用代码不需要更改。

