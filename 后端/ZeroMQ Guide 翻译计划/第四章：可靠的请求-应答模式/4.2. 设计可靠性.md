# 设计可靠性

简单地说，可靠性就是“在代码冻结或崩溃时（简称为“死亡”）保持正常工作”。然而，想保持正常工作比消息本身更复杂。我们需要检查每个 ZeroMQ 核心消息模式，并考虑如何使它们在“死亡”情况下工作正常。

让我们遍历一下 ZeroMQ 的核心消息模式：

- 请求-应答：如果服务端死亡（在处理一个请求时），客户端能感知到这种情况，因为客户端会长时间收不到应答返回。然后可以选择放弃，等待一段时间后重试，寻找其他服务端，等等。如果是客户端死了，我们暂时可以将它当做“别人的问题”来处理
- 发布-订阅：如果客户端死亡（已经获取到了部分数据），服务端将不会知道。发布-订阅并不会将任何信息从客户端发回给服务端。但是客户端在连接服务时可以使用带外数据，例如请求-回复，并询问“请重新发送我错误的所有内容”。如果是服务端死亡，这里暂不讨论。订阅者还可以自我验证是否运行的太慢，如果运行太慢就采取行动（例如，警告操作员然后退出）。
- 管道：如果 worker 死亡（正工作时），ventilator 也不会知道。管道，就像时间的齿轮，只能朝一个方向转动。但下游收集器可以检测到某个任务没完成，并像 ventilator 发送消息说，“嘿，重新发送任务 324！”。如果 ventilator 或收集器死亡，上游客户端在等待超时后就会重新发送整批任务，不管之前上游客户端发送了什么任务。这并不优雅，但系统代码真的不应该经常死亡

在本章，我们只关心请求-应答，这是最容易实现的可靠消息模式。

基本的请求-应答模式（一个 REQ 客户端套接字进行阻塞发送/接收到一个 REP 服务端套接字）在处理常见失败类型时得分最低。如果服务端在处理请求时奔溃了，客户端只能一直挂着。如果请求或返回在网络上丢失了，客户端也只能一直挂着。

由于 ZeroMQ 能够自动重连对等端、对消息进行负载均衡等等，因此基本的请求-应答模式仍然比 TCP 好得多。但对于真正的工作来说，它任然不够好。只有在同一个进程的两个线程之间通信时，基本的请求-应答模式才是可以信任的，因为没有网络通信，也没有哪一端可以单独终止。

然而，只需要一点额外的工作，这个简单的模式可以成为跨分布式网络进行实际工作的良好基础，并且进化成一组可靠的请求-应答（RERR）模式，我将其称为 Pirate 模式（希望你最终能 get 到这个笑话）。

根据我的经验，大约有三种方法可以将客户端连接到服务端。每一种都需要一种特定的方法来保证可靠性：

- 多个客户端直接和单个服务端通信。例如：多个客户端连接一个知名的服务端。我们需要处理的故障类型：服务端奔溃和重启，以及网络断开
- 多个客户端和一个 broker 代理通信，broker 将工作分发到多个 worker。例如：面向服务的事务处理。我们需要处理的故障类型：worker 崩溃和重启，worker 忙循环，worker 过载，队列崩溃、重启、以及网络断开
- 多个客户机直接和多个服务端通信，没有中间代理。例如域名服务器。我们需要处理的故障类型：服务崩溃和重启，服务忙循环，服务过载，以及网络断开

每一种方法都有优缺点，而且通常会混用。我们将详细的讨论这三种情况。

