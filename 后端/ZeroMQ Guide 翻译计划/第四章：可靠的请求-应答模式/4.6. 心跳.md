# 心跳

心跳解决了知晓通信对等端是死是活的问题。这不是 ZeroMQ 特有的问题。TCP 超时时间太长（大约 30 分钟），在超时时间之内，无法得知对等端是否已经死亡、断连、或者是周末带着一箱伏特加、一个红发女郎和一个大额开支账户去了布拉格潇洒。

要让心跳正常并不容易。在编写偏执型 pirate 示例时，花费了大约 5 小时才让使心跳正常。其他部分大概花费了 10 分钟。很容易产生 “错误的失败”，例如，对等端因为心跳不正常而决定断开连接。

我们来看看人们在使用 ZeroMQ 心跳时的三种主要做法。

## 不要心跳

最常见的方法是不使用心跳，并抱乐观希望。许多（但不是大多数）ZeroMQ 应用程序都会这样做。ZeroMQ  在许多场景下都会隐藏对等点，鼓励了不使用心跳的做法。但这种做法会导致哪些问题呢？

- 假如在一个跟踪对等点的应用程序中使用 ROUTER 套接字时，当对等点断开并重连时，应用程序将发生内存泄露（应用程序为对等点维护的资源），速度会越来越慢。
- 当使用基于 SUB- 或 DEALER- 的数据接收时，无法区分好的沉默（没有数据）和坏的沉默（另一端已经死亡）。当接收端知道另一端已经死亡时，它可以采取行动，例如切换到备份路由。
- 如果我们使用一个长时间保持沉默的 TCP 连接，在某些网络中，这个连接可能会死亡。发送一些数据（从技术上讲，“保持存活”比心跳更重要）将保持连接活跃。

## 单向心跳

第二个选项是每隔一秒钟左右从每个节点向对等点发送一条心跳消息。当一个节点在某个超时时间内（一般为几秒）没有收到对等点的任何消息时，它将把该节点视为已死。听起来不错，对吧？很遗憾，并不是。这种方法只在某些情况下有效，但在另一个情况下却很危险。

对于发布-订阅，这是可行的，这也是唯一适用的模型。SUB 套接字不能主动向 PUB 套接字通信，但 PUB 套接字可以愉快地向它们的订阅者发送“我还活着”的消息。

作为一种优化，你可以只在没有实际数据要发生时才发送心跳。此外，如果网络活动需要耗费资源（例如在电源容易耗尽的移动网络上），你可以将心跳发送得越来越慢。只要接收者能够检测到故障（活动的急剧停止）就行。

下面就是这种设计的典型问题：

- 当我们发送大量数据时，可能会不准确，因为心跳会在数据后面延迟发送。如果心跳延迟了，可能会由于网络阻塞而导致心跳错误的超时而断开连接。因此，建议无论发送方是否优化了心跳，始终将任何传入的数据视为心跳。
- 发布-订阅模式在接收方消失时丢弃消息，PUSH 和 DEALER 套接字将对消息进行排队。所以如果你把心跳发送给一个死去的对等端，在对等端重新上线后，它会收到你所有的心跳，可能有上千个。这酸爽！
- 这种设计假设整个网络中的心跳超时都是相同的。这并不科学，一些对等端为了快速发现错误，可能需要非常频率很高的心跳。而另一些对等端则需要频率很低的心跳，以便让网络静默并节省电力。

## 乒乓心跳















































