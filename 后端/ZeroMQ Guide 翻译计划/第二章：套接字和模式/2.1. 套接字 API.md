# 套接字 API

> 本文翻译自[套接字 API](http://zguide.zeromq.org/page:all#The-Socket-API)

坦白地说，ZeroMQ 对你耍了一点小把戏，但是我们不会道歉。这是为了你好，我们受到的伤害比你更多。ZeroMQ 提供了一组大家熟悉的类似套接字的 API，为此我们付出了巨大的努力来隐藏一堆消息处理引擎。这样做的结果是慢慢修正你关于如何设计和编写分布式软件的世界观。

套接字是网络编程事实上的标准 API，而且对于防止眼睛掉到脸颊上十分有用。ZeroMQ 对开发人员特别有吸引力的一点是，它使用了套接字和消息概念，将“面向消息的中间件”变成了“额外辛辣的套接字”，这让我们对披萨产生了一种奇怪的渴望，并渴望了解更多。

就像最爱的食物一样，ZeroMQ 套接字易于消化。ZeroMQ 套接字的生命周期和 BSD 套接字的生命一样分为四部分：

- 创建和销毁套接字，一起组成了套接字的生命循环。（参见 `zmq_socket()`,`zmq_close()`）
- 配置套接字，通过设置套接字上的选项并在必要时进行检查。（参见`zmq_setsocketopt()`,`zmq_getsocketopt()`）
- 将套接字插入到网络拓扑中，通过创建 ZeroMQ 连接。（参见 `zmq_bind()`, `zmq_connect()`）
- 使用套接字传输数据，通过在套接字上写和接收消息。（参见`zmq_msg_send()`, `zmq_msg_recv()`）

注意，套接字总是 void 指针，消息（我们很快会讲到）是结构体。所以在 C 语言中，你可以直接传递套接字变量，但传递消息给相关函数时传递地址就行，例如 `zmq_msg_send()` 和 `zmq_msg_recv()`。作为一个助记符，你需要认识到“在 ZeroMQ 中，你创建的所有套接字都属于我们，消息才属于你”。

创建、销毁和配置套接字的工作原理和你对任何对象的期望一样。但你需要记住，ZeroMQ 是一个异步的，有弹性的结构。这一定程度上影响了我们如何将套接字插入到网络拓扑中以及如果使用套接字。

## 将套接字插入到拓扑结构中

要在两个节点间创建连接，你需要在一个节点上调用`zmq_bind()` ，并在另一个节点上调用 `zmq_connect()` 。一般来说，执行 `zmq_bind` 的节点称为 `server`，绑定一个大家都知道的网络地址，而执行 `zmq_connect()` 的节点是 “client”，使用任意的网络地址。因此，我们说“将套接字绑定到一个端点”和“将套接字连接到一个端点”，这个端点就是这个大家都知道的网络地址。

ZeroMQ 连接和传统的 TCP 连接有些不同。其主要的显著差异有：

- ZeroMQ 可以基于任意的传输协议（`inproc`, `ipc`, `tcp`, `pgm`, 或 `epgm`）。参见`zmq_inproc()`, `zmq_ipc()`, `zmq_tcp()`, `zmq_pgm()`, 以及 `zmq_epgm()`。
- 一个套接字可以有多个传出和传入连接。
- 没有 `zmq_accept()` 方法。当一个套接字绑定到一个端点后，会自动开始接受连接。
- 网络连接本身发生在后台，ZeroMQ 会自动在网络连接中断（例如，对等端消失、然后返回）后进行重连。
- 你的应用程序代码不能直接使用这些连接，连接被封装在套接字之下。

许多架构遵循某种客户机/服务器模型。其中服务器是最静态的组件，客户机是最动态的组件，客户机来了又走的的情况最多。有时候会存在寻址问题：服务器对客户机可见，但客户机不一定对服务器可见。因此，这就很明显的决定了哪个节点需要执行 `zmq_bind()`（服务器），哪个节点需要执行 `zmq_connect()`（客户机）。这也依赖于你使用的套接字类型，对于一些不常见的网络结构除外。稍后我们会关注套接字类型。

假设我们在启动服务器之前启动了客户机。在传统的网络中，我们会得到一个大大的红色失败标志。但是 ZeroMQ 允许我们以任意顺序启动和停止各个组件。只有客户机执行了 `zmq_connect()`。连接就已经存在，该阶段就可以开始向套集资写入消息。在某个阶段（希望是在消息没积累太多而导致消息被丢弃或客户机被阻塞之前），服务器启动，执行 `zmq_bind()`，ZeroMQ 开始传递消息。

一个服务节点可以绑定到多个端点（即协议和端口的组合），并且只需要使用一个套接字就可以实现。这意味着它接受跨不同传输协议的连接：

```c
zmq_bind (socket, "tcp://*:5555");
zmq_bind (socket, "tcp://*:9999");
zmq_bind (socket, "inproc://somename");
```

大多数传输协议不像 UDP 协议一样允许你在同一个端点上绑定两次。然而，`ipc` 协议可以，让一个进程绑定到一个已被之前进程使用的端点。这意味着允许进程在奔溃后恢复。

虽然 ZeroMQ 试图对哪端执行绑定和哪端执行连接保持中立，但是还是有区别的。我们稍后会看到更多细节。结果就是，你通常应该将“服务器”视为拓扑结构中静态部分，绑定到一个或多个固定的端点，将“客户机”视为动态部分，它们来来去去并连接到这些固定端点。然后，围绕这个模型来设计应用程序，它“正常工作”的可能性最大。

套接字有不同的类型。套接字的类型定义了套接字的语义、向内向外路由消息的策略、队列等。你可以连接特定类型的套接字，例如，发布者套接字和订阅者套接字。套接字在“消息传递模型”中协同工作。稍后我们将更详细的讨论这些。

正是这些不同的套接字连接方式使 ZeroMQ 具备了作为消息队列系统的基本能力。在此之上还有一个些层，比如代理，我们稍后会讨论它。但从本质上来说，使用 ZeroMQ，你可以像孩子拼接玩具一样定义你的网络体系结构。

## 发送和接收消息

















