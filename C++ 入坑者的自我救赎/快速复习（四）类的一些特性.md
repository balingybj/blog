# 快速复习（四）：类的一些特性

本篇不会记录关于 C++ 类的所有语法，只记录平时编程涉及不多，印象不深的那些特性。

## 类定义相关

### 使用 =default 要求编译器提供默认的构造函数

我们知道，如果你为类定义了构造函数，编译器就不在为类提供默认的构造函数。但如果你提供了自己的构造函数版本，又需要一个简单的默认构造函数，又不想麻烦自己去定义，这时候就可以使用 `=default` 来要求编译器提供默认的构造函数。具体用法是声明一个构造函数，并在参数列表后面加上 `=default`。eg:

```c++
class Base
{
public:
  Base()=default;
  // ...
}
```

`=default` 构造函数既可以出现在类内部，也可以出现在外部。出现在内部，默认为内联函数，出现在外部，默认不内联。

### 类数据成员的初始值

出了在构造函数的初始化列表中初始化成员变量外，C++11 还规定了**类内初始值**来为数据成员提供初始值。

类内初始值是在成员变量声明时使用`=`或花括号初始化变量。例如：

```c++
class Base
{
public:
	int num = 0;
	std::vector<Screen> screens{Screen(24, 80, ' ')};
}
```

## 访问控制相关

### 理解友元的声明

友元声明只能出现在类定义的内部，但在类内的具体位置不限。友元也不是类的成员，也不受区域访问控制的影响。

一般建议在类的开头或结尾前集中声明友元。

需要特别注意的是：友元声明不同于通常意义上的函数声明。友元声明仅仅指定了访问的权限，如果需要类的用户能够调用某个友元函数，则还需要在友元声明之外再专门对函数进行一次声明。

通常将友元的声明与类本身放置在同一个头文件中。

## 类的其他特性

### 定义类型成员

出了定义数据成员和函数成员外，还可以定义类型成员。类型成员是某种类型在类中的别名。类型成员和其他成员一样受访问权限限制。定义语法为在类内：

```c++
typedef 原类型名 新类型名;
```

或者使用 C++11 引入的 using，语法更明确

```c++
using 新类型名 = 原类型名
```

至于为什么使用类型成员，我觉得这样可以屏蔽实现细节，比如 C++ 容器中都提供了类型成员，比如 string::size_type、map:value_type。

### 内联成员函数

我们知道在类内定义的成员函数，自动是 inline 的。我们还可以在成员函数的声明和类外部定义前显示指定 inline。可以在声明和定义处同时指定 inline 关键字，但一般建议只在类外部的定义初说明 inline 就行。

和其他 inline 函数一样，inline 成员的函数的声明和定义必须在同一个头文件中。

### 可变数据成员

我们知道 const 成员函数不能修改成员变量。但有时候我们喜欢某个变量能被 const 成员函数修改，即使在 const 对象中。我们可以在该成员变量的声明前使用 `mutable` 关键字。该变量就成了可变数据成员。

一个可变数据成员永远不会使 const，即使它是 const 对象的成员。而且 const 成员函数也可以修改可变数据成员的值。

### 从 const 成员函数返回 *this 和 基于 const 的重载

我们知道从成员函数返回 *this 的引用，即对象本身，可以方便的支持链式调用。当对于 const 成员函数，它的 this 指针将指向 const，const 成员函数不会修改内容，返回类型也一般是指向 const 对象的引用。如果将 const 成员函数用在链式调用中，就不能再调用非 const 成员函数了。

为了解决这个麻烦，我们可以对对应的 const  的成员函数提供非 const 的重载版本。这个重载版本完成的功能一样，只是返回类型为非 const，在函数体中可以直接调用 const 版本，然后返回非 const 的 *this。

## 构造函数相关

### 委托构造函数

C++11 的新内容，委托构造函数就是一个构造函数可以在其初始化列表中调用其他构造函数。也就是将一部分初始化过程委托给其他构造函数。

委托构造函数不能再使用初始化器，初始化其他成员。也就是委托构造函数的初始化列表中只能出现一个对其他构造函数的调用。

执行顺序是，先执行受委托的构造函数的初始值列表和函数体，然后执行委托的函数体。

### 隐式的类类型转换、explicit

类有一种隐式转换规则，如果类有一个只需一个实参调用的构造函数，它实际上定义了从该实参类型到类对象的转换规则。比如 string 有一个接受const char* 类型参数的构造函数，所以在需要的时候，"hello world" 可能会隐式转换成一个 string 对象。例如：

```c++
string s = 'hello world';
```

隐式转换只会发生一步，不可能将一个变量隐式转换成 a 对象，然后又隐式转换成 b 对象。

#### 用 explicit 阻止隐式类类型转换

有时候这种隐式转换不一定是有意义的。为了安全，你可以在相应的构造函数声明前面加上 `explicit` 关键字。以后只能使用显示的转换操作才能达到同样的目的。

## 聚合类

todo

## 字面值常量类

todo