# 分阶段翻译

编译器处理 C++ 源代码文件时依次会经过如下几个步骤。

## 阶段一

1. 源代码文件中的各个单独字节（以实现特定的方式）映射为 *基本源字符集* 中的字符。其中，依赖于操作系统的行尾指示符被替换为换行符。*基本源字符集* 由以下 96 个字符组成：
    - 5 个空白字符（空格，水平制表符，纵向制表符，换页，换行 ）
    - 10 个数字字符， 从 `'0'` 到 `'9'`
    - 52 个字母，从 `'a'` 到 `'z'` 以及 `'A'` 到 `'Z'`
    - 29 个标点字符：`_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '`
2. 源代码文件中的无法映射到 *基本源字符集* 的字符都被替换为 *通用字符名*（用 `\u` 或 `\U` 转义），或者有具体的编译器实现以同等的方式处理。
3. 将三标符序列替换为对应的单字符表示。（until C++17）

## 阶段二

1. 凡是出现在行尾的反斜杠（也就是反斜杠后面紧跟了一个换行符），反斜杠和换行符都被删除，这样原本在物理上属于两行的代码合并为逻辑上的一行。这个操作只会在相关行上执行一次，行尾出现两个反斜杠+两个换行符的情况并不会导致物理上的三行被合并为逻辑上的一行。如果该阶段产生了一个通用字符名（`\uXXX`），则行为未定义。
2. 如果一个非空的源代码文件经历完前一个步骤后不是以换行符结尾（可能最初文件结尾就没有换行符，或者以反斜杠结束），在 C++11 之前，会导致未定义行为，在 C++11 之后会编译器会在源代码文件末尾补上一个换行符。

## 阶段三

1. 源文件被分解为注释，空白字符序列（空格、水平制表符、换行符、纵向制表符、换页符），以及以下各种预处理标记：
    - 头文件名，例如 `<iostream>`,`"myfile.h"`
    - 标识符
    - 预处理数字
    - 字符和字符串字面量，从 C++11 起，还包括用户定义的字面量
    - 运算符和标点（包括代用记号），比如 `+`、`<<=`、`new`、`<%`、`##`、`and`
    - 不属于其他类别的单独空白字符
2. 任何在阶段一和阶段二对双引号之间的原始字符串字面值作的变化都被还原（since C++11）
3. 每段注释替换为一个空格

换行符被保留，但并没有指定是否将除换行符之外的空白字符折叠成单个空格。

输入序列被解析为预处理标记，直到某个指定字符。通常将能构成一个预处理记号的最长字符序列处理成下一个预处理标记，即使这样会导致后续解析失败。这就是常常提到的 *最大吞噬（maximal munch）*。

```c++
int foo = 1;
int bar = 0xE+foo;   // 错误：非法的预处理数字 0xE+foo
int baz = 0xE + foo; // 正常

int quux = bar+++++baz; // 错误：bar++ ++ +baz，而非 bar++ + ++baz。
```

最大吞噬规则的例外是：

- 如果下一个字符所开始的字符序列可以作为 *原始字符串字面量* 的前缀或起始双引号，则下个预处理标记为原始字符串字面量。该字面量由匹配原始字符串模式的最短字符序列组成。

    ```c++
    #define R "x"
    const char* s = R"y"; // 格式错误的原始字符串字面量，而非 "x" "y"
    const char* s2 = R"(a)" "b)"; // 原始字符串字面量后随普通字符串字面量
    ```

- 如果下三个字符为 `<::` 并且后续字符不是 `:` 或 `>`，`<` 自身被当做预处理标记（而不是 *代用标记* `<:` 的首字符）。（since C++11）

    ```c++
    struct Foo { static const int v = 1; };
    std::vector<::Foo> x; // OK，<: 未被当作 [ 的代用记号
    extern int y<::>;     // OK，同 extern int y[]。
    int z<:::Foo::value:>; // OK，int z[::Foo::value];
    ```

- 头文件预处理标记只会在 `#include` 指令后形成

    ```c++
    std::vector<int> x; // <int> 没有被解析为头文件名
    ```

## 阶段四

1. 执行 *预处理器*
2. 每个有 `#include` 指令引入的文件都经历阶段一到阶段四的处理，这个过程是递归的
3. 此阶段结束后，源代码中所有的预处理器指令都被移除

## 阶段五

1. 所以字符字面量和字符串字面量中的字符都从源字符集转到 *执行字符集* （可以是 UTF-8 这种多字符集，因为阶段一中列出的基本源字符集中的 96 个字符都可以用单个字节表示）
2. 将字符字面量和非原始字符串字面量中的转义序列和通用字符名展开，并转换到 *执行字符集*。如果通用字符名指定的字符不属于执行字符集，则结果由实现定义，但是保证不是空（宽）字符

注意：某些编译器实现提供了命令行选项来控制此阶段的转换：gcc 和 clang 使用 `-finupt-charset` 指定源字符集的编码，使用 `-fexec-charset` 和 `-fwide-exec-charset` 指定无编码前缀（since C++ 11）的字符串和字符字面值的执行字符集的编码。Visual Studio 2018 Update 2 使用 `/source-charset` 和`/execution-charset` 指定源字符集和执行字符集。

## 阶段六

拼接相邻的字符串字面量

## 阶段七

编译：每个预处理标记转换成标记。将这些标记进行语法和语义上分析，并作为分析单元进行翻译。

## 阶段八

检查每个翻译单元，生成需要模板实例化的列表，包括显示实例化请求的模板实例化。定位模板的定义，执行所需的实例化，生成实例化单元（单个或多个）。

## 阶段九

将翻译单元，实例化单元，以及满足外部调用所需的库组件汇集成一个程序映像，该映像包含了在其执行环境执行时需要的信息。

## 注意

有些编译器没有实现实例化单元（也称作模板库或模板注册表），而是在阶段七简单地编译模板实例化，将代码存在其所显示或隐式要求的对象文件中，然后在阶段九由链接器将这些编译后的实例化压缩到一个。





















