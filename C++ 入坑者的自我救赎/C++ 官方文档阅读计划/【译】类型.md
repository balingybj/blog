# 类型

> 本文翻页自 C++ 官方文档 [Type](https://en.cppreference.com/w/cpp/language/type)，并补充了笔者自己的理解和示例。

对象、引用、函数（包括函数函数模板特化）和表达式具有称为类型的性质。类型限制了能对这些实体执行的操作，并给原本寻常的二进制位序列附加了语义。

## 类型分类

C++ 类型系统包括两大类：

- 基本类型
    - `void` 类型
    - `std::nullptr_t` 类型（since C++11）
    - 算术类型
        - 浮点类型：`float`,`double`,`long double`
        - 整数类型
            - `bool` 类型
            - 字符类型
                - 窄字符类型：
                    - 普通字符类型：`char`、`signed char`、`unsigned char`
                    - `char8_t` 类型
                - 宽字符类型：`chat16_t`、`char32_t`、`wchar_t`
            - 有符号整数类型：`short int`、`int`、`long int`、`long long int`
            - 无符号整数类型：`unsigned short int`、`unsigned int`、`unsigned long int`、`unsigned long long int`
- 复合类型
    - 引用类型
        - 左值引用类型
            - 对象的左值引用类型
            - 函数的左值引用类型
        - 右值引用类型
            - 对象的右值引用类型
            - 函数的右值引用类型
    - 指针类型
        - 指向对象类型
        - 指向函数类型
    - 指向成员的指针类型
        - 指向数据成员的指针类型
        - 指向成员方法的指针类型
    - 数组类型
    - 函数类型
    - 枚举类型
    - 类类型
        - 非联合体类型
        - 联合体类型

另外，C++ 类型系统还支持在以上类型（除引用和函数外）前添加三种 cv 限定符：`const`、`volatile`、`const volatile`（这些限定符以字母  `c`、`v` 开头，所以称为 cv 限定符）。添加限定符后又形成新的类型。

这些类型根据属性又可以分为以下不同类别：

- 对象类型：除函数、引用、void 之外的类型
- 标量类型：除数组、类之外的类型
- 平凡类型、POD 类型、字面类型、以及在[类型特征库](https://en.cppreference.com/w/cpp/types)和[具名类型要求](https://en.cppreference.com/w/cpp/named_req)中列出的其他类别。

## 给类型命名

通过以下方式可以声明一个名字来指代一个类型：

- 类声明
- 枚举声明
- typedef 声明
- 类型别名声明

在 C++ 程序中通常通过 *type-id*（类型标识符）语法来引用没有名字的类型。type-id 的语法类似声明一个对应类型的变量或函数，不过省略了变量标识符，且声明说明符序列被限制为类型说明符序列，且仅当类型标识符出现在非模板别名声明的右侧时，才可以定义新类型。

```c++
int* p;                // 声明 int 的指针
static_cast<int*>(p);  // 类型标识符为 int*
```

上面代码中的 `int*` 并没有名称，但却可以声明表达式中指定变量 p 的类型，以及在 `static_cast` 类型转换表达式中指定转换后的类型。

```c++
int a[3];    // 定义一个包含 3 个 int 的变量 a
new int[3];  // type-id 为 int[3]
```

```c++
int (*(*x[2])())[3];  // 声明一个包含两个指针的数组，指针指向函数，函数返回一个指向包含 3 个 int 的数组
new (int (*(*[2])())[3]);  // type-id 为 int (*(*[2])())[3]
```

```c++
void f(int);  // 声明一个函数，该函数接收一个 int 参数，并返回 void
std::function<void(int)> x = f;  // 该模板的类型模板参数为 type-id "void(int)"
std::function<auto(int) -> void> y = f; // 同上
```

```c++
std::vector<int> v;  // 声明一个元素类型为 int 的vector
sizeof(std::vector<int>);  // type-id 为 std::vector<int>
```

```c++
struct { int x; } b;   // 定义一个新类型，并声明了该类型的变量 b
sizeof(struct{ int x; });  // 错误：不能再 sizeof 表达式中定义新类型
using t = struct { int x; };  // 创建一个新类型，并为该新类型声明一个别名 t
```

```c++
sizeof(static int);  // 错误：static 是存储类型说明符，而存储类型说明符不能出现在类型说明符序列中
std::function<inline void(int)> f;  // 错误：函数说明符也不能出现在类型说明符序列中
```

声明语法的声明符部分去掉了名字后被称为抽象声明符。

type-id 可用于以下场景：

-   指定转型表达式的目标类型
-   作为 `sizeof`,`alignof`,`alignas`,`new` 和 `typeid` 的实参
-   出现在类型别名声明的右侧
-   作为函数声明的尾随返回类型
-   作为模板类型参数的默认实参
-   作为模板类型参数的模板实参
-   在动态异常规范中

type-id 经过一些修改可以使用在以下场景中：

-   在函数的行参列表中（省略参数名时），type-id 使用声明描述符序列而不是类型描述符序列（特别是允许使用某些存储类型说明符）
-   在用户定义转换函数中，抽象声明符不能包括函数或数组运算符

## 详述类型说明符

详述类型说明符用于引入前面定义过的类名（class，struct，union）或枚举名，即使对应的名称被非类型声明隐藏。也可以用于声明新的类名。

参见[Elaborated type specifier](https://en.cppreference.com/w/cpp/language/elaborated_type_specifier)

## 静态类型

程序编译时分析出的的表达式类型成为表达式的静态类型。静态类型在程序允许时不会改变。

## 动态类型

如果一个泛左值表达式引用某个多态对象，则其最终派生对象的类型被称为动态类型。

```c++
struct B { virtual ~B() {} }; // 多态类型
struct D: B {}; // 多态类型
D d; // 最终派生对象
B* ptr = &d;
// (*ptr) 的静态类型为 B
// (*ptr) 的动态类型为 D
```

对纯右值表达式，其动态类型和静态类型总是相同。

关于值类型，参见 [Vaule categories](https://en.cppreference.com/w/cpp/language/value_category)

## 不完整类型

以下类型属于不完整类型：

- void 类型（可以有 cv-限定符）
- 被声明但是没有被定义的类类型
- 未知边界数组
- 元素为不完整类型的数组
- 枚举类型从声明点到其底层类型被确定之间都属于不完整类型

下面列出的上下文中都要求类型 T 是完整类型，一般是需要指定 类型 T 的大小和布局：

- 返回类型为 T 或参数为 T 的函数定义或函数调用
- 定义 T 类型对象
- 声明一个 T 类型的非静态类数据成员
- new 一个类型为 T 的对象，或 new 一个元素类型为 T 的数组
- 对 T 类型泛左值实施左值到右值转换
- 到类型 T 的隐式或显示转换
- 到 T* 或 T& 类型的标准转换、dynamic_cast 或 static_cast 转换，包含从空指针常量或 void 指针的转换
- 对 T 类型表达式使用类成员访问运算符
- 对 T 类型使用 sizeof、typeid 或 alignof 运算符
- 对 T 类型指针进行算术运算
- 定 T 类型的扩展类
- 给 T 类型的左值赋值
- T、T&、T* 类型异常的 catch 子句

如果以上任何一种情况出现在某个编译单元中，则 T 的定义必须也出现在该编译单元中。

不完整定义对象可以变得完整：

- 一个类类型，假设为 `class X`，在某个编译单元中可以是不完整类型，然后到达该编译单元的另一个点的变成完整类型。`class X` 在两个点都是相同类型。

    ```c++
    class X;              // X 为不完整类型
    extern X* xp;         // xp 是向一个不完整类型的指针
     
    void foo() {
      xp++;               // 错误: X 不完整，无法得知X的大小，指针运算无法完成
    }
     
    struct X { int i; };  // X 现在是一个完整类型了
     
    X x;
    void bar() {
      xp = &x;            // 正确: xp 是执行类型 x 的指针
      xp++;               // O正确: X 现在是完整类型，可以进行指针的算术运行
    }
    ```

- 声明一个数组，其元素类是不完整的，则该数组是不完整的，如果后面在该编译单元中对应的类类型变得完整了，则该数组也变成完整。两处的数组类型是同一类型

- 在同一个编译单元中，声明一个未知边界的数组对象，此处该数组类型是不完整的，并且在随后某处可能变得完整。数组类型在两处都属于同一类型

指向未知边界数据的指针类型或者通过 `typedef` 定义的未知边界数组类型永远无法变得完整。

