## 理解复合类型的声明

变量的定义包括一个基本数据类型和一组声明符。在一条定义语句中，基本数据类型只能有一个，但可以有多个不同形式的声明符。例如

```c++
int i = 1024, *p = &i, &r = i;
```

这条定义语句的基本数据类型为 int，但却有`*`、`&`修饰符，就是说，一条定义语句可以定义不同类型的变量。

## 指针和 const

### 指向常量的指针

指针本身不是常量，指针指向的变量是常量。也就是说不能通过指针修改变量，但可以修改指针的指向。

`const double *cptr = &pi`

指向常量的指针也可以指向非常量变量。

>   所谓执行常量的指针或引用，只不过是种权限约束，表示不能通过它们改变所指对象。

### const 指针（常量指针）

指针本身为常量，但指向的变量不一定是常量。

`double *const pctr = &pi`

### 理解和读法

我们容易混淆指向常量的指针和 const 指针。C++ Primer 上推荐的办法是从右往左阅读定义语句。比如：

`int *const curErr = &errNumb;`

离 `curErr` 最近的符号是 `const`，意味着 `curErr` 本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符的下一个符号是 `*`，表示 `curErr` 是一个常量指针。最后基本数据类型表示常量指针指向的是一个 `int` 对象。

## 顶层 const 和底层 const

**顶层 const**：对象本身是常量，比如 const 指针

**底层 const**：所指向的对象是常量。

指针类型既可以是顶层 const，也可以是底层 const。

`const int *const p = &i`，p 本身是常量，指向的对象也是常量。

### 拷贝时的影响

顶层 const 不影响拷贝。顶层 const 表示变量本身是常量，将一个常量的值拷贝给一个非常量，当然没问题，只不过是将值给另外的变量拷贝一份，不会影响该常量。反过来也没问题，都是指传递。

底层 const 就要小心了。底层 const 表示指向的对象是常量，不能修改。如果将一个指向常量的指针变量拷贝给一个普通指针变量，那么将可以通过后者修改指向的对象，无疑扩大的权限，也就是将常量转换成了非常量，所以是不允许的。当然，可以将一个普通指针变量拷贝给指向常量的指针变量。缩小权限当然可以。

## constexpr 和常量表达式

**常量表达式**指值不会改变并且在编译时就能得到计算结果的表达式。一般常量表达式包括：

-   字面值
-   用常量表达式初始化的 const 对象

根据上面第二种情况，一个对象或表达式是不是常量表达式可以根据数据类型和初始值共同判断，例如：

```C++
const int max_files = 20;  // 是
const int limit = max_files + 1; // 是，max_files + 1 在编译期就可以计算出来
int staff_size = 27; // 不是，因为变量类型不是 const，尽管27是字面值
const int sz = get_size(); // 不是，get_size() 在运行时才会返回结果
```

### 用 constexpr 强制约束常量的初始值为常量表达式

在复杂的系统中，很难分辨一个初始值是否为常量表达式。如果我们定义一个 const 常量，并希望用常量表达式来初始化它，但实际使用时，你不能保证这个初试化的值就是常量表达式，可能会造成对象的定义和使用根本是两回事。

C++11 引入了一个新的 `constexpr` 修饰符。用 `constexpr` 修饰的变量一定是一个常量，且必须用常量表达式初始化。这样就将麻烦丢给了编译器。将由编译器来保证这一点。

```c++
constexpr int sz = size(); // 只有在 size 是一个 constexpr 函数时，该语句才能通过编译
```

